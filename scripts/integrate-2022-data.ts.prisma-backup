/**
 * Script to integrate KCET 2022 data into the prediction system
 * This will parse the 2022 data and combine it with 2023 data for training
 */

import { PrismaClient } from '@prisma/client';
import * as fs from 'fs';
import * as path from 'path';

const prisma = new PrismaClient();

interface ParsedCutoff {
  collegeCode: string;
  collegeName: string;
  branch: string;
  branchCode: string;
  category: string;
  rank: number;
  year: number;
  round: string;
}

/**
 * Parse the raw 2022 KCET data
 */
function parse2022Data(rawText: string): ParsedCutoff[] {
  const entries: ParsedCutoff[] = [];
  const lines = rawText.split('\n');
  
  let currentCollege = { code: '', name: '', location: '' };
  let categoryHeaders: string[] = [];
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;
    
    // Match college header: "1     E001   University of Visvesvaraya..."
    const collegeMatch = line.match(/^\d+\s+(E\d+)\s+(.+?)(?:\s{2,}|\t)/);
    if (collegeMatch) {
      currentCollege.code = collegeMatch[1];
      const nameLocation = collegeMatch[2].trim();
      const parts = nameLocation.split(/\s{2,}/);
      currentCollege.name = parts[0];
      currentCollege.location = parts[parts.length - 1] || '';
      continue;
    }
    
    // Match category headers
    if (line.match(/^1G\s+1K\s+1R\s+2AG/)) {
      categoryHeaders = line.split(/\s+/).filter(h => h.length > 0);
      continue;
    }
    
    // Match branch data lines
    const branchMatch = line.match(/^([A-Z]{2})\s+(.+?)\s+(\d+)/);
    if (branchMatch && currentCollege.code) {
      const branchCode = branchMatch[1];
      const parts = line.split(/\s+/);
      
      // Find where branch name ends (first number after branch code)
      let branchNameEnd = 2;
      while (branchNameEnd < parts.length && !/^\d+$/.test(parts[branchNameEnd])) {
        branchNameEnd++;
      }
      
      const branchName = parts.slice(1, branchNameEnd).join(' ');
      const ranks = parts.slice(branchNameEnd);
      
      // Map ranks to categories
      ranks.forEach((rank, index) => {
        if (rank !== '--' && /^\d+$/.test(rank) && index < categoryHeaders.length) {
          entries.push({
            collegeCode: currentCollege.code,
            collegeName: currentCollege.name,
            branch: branchName,
            branchCode: branchCode,
            category: categoryHeaders[index],
            rank: parseInt(rank),
            year: 2022,
            round: 'FIRST'
          });
        }
      });
    }
  }
  
  return entries;
}

/**
 * Import 2022 data into database
 */
async function import2022Data() {
  try {
    console.log('üìñ Reading 2022 KCET data...');
    
    // Read the raw data file
    const dataPath = path.join(process.cwd(), 'data', 'kcet-2022-raw.txt');
    const rawData = fs.readFileSync(dataPath, 'utf-8');
    
    console.log('üîç Parsing 2022 data...');
    const parsedData = parse2022Data(rawData);
    
    console.log(`‚úÖ Parsed ${parsedData.length} cutoff entries`);
    
    // Group by college for batch insertion
    const collegeMap = new Map<string, ParsedCutoff[]>();
    parsedData.forEach(entry => {
      if (!collegeMap.has(entry.collegeCode)) {
        collegeMap.set(entry.collegeCode, []);
      }
      collegeMap.get(entry.collegeCode)!.push(entry);
    });
    
    console.log(`üìä Found ${collegeMap.size} unique colleges`);
    
    let importedCount = 0;
    let skippedCount = 0;
    
    for (const [collegeCode, entries] of Array.from(collegeMap.entries())) {
      try {
        // Find or create college
        let college = await prisma.college.findFirst({
          where: { code: collegeCode }
        });
        
        if (!college) {
          const firstEntry = entries[0];
          college = await prisma.college.create({
            data: {
              code: collegeCode,
              name: firstEntry.collegeName,
              location: 'Karnataka', // Default location
              type: firstEntry.collegeName.toLowerCase().includes('government') ? 'Government' : 'Private',
              established: 2000, // Default year
              affiliation: 'VTU',
              facilities: [],
              courses: []
            }
          });
          console.log(`‚ú® Created college: ${college.name}`);
        }
        
        // Import cutoffs for this college
        for (const entry of entries) {
          try {
            // Check if cutoff already exists
            const existing = await prisma.cutoff.findFirst({
              where: {
                collegeId: college.id,
                branch: entry.branch,
                category: entry.category,
                year: entry.year,
                round: entry.round
              }
            });
            
            if (existing) {
              skippedCount++;
              continue;
            }
            
            await prisma.cutoff.create({
              data: {
                collegeId: college.id,
                branch: entry.branch,
                category: entry.category,
                rank: entry.rank,
                year: entry.year,
                round: entry.round
              }
            });
            
            importedCount++;
          } catch (error) {
            console.error(`‚ùå Error importing cutoff for ${entry.branch}:`, error);
          }
        }
      } catch (error) {
        console.error(`‚ùå Error processing college ${collegeCode}:`, error);
      }
    }
    
    console.log('\nüìä Import Summary:');
    console.log(`‚úÖ Imported: ${importedCount} cutoffs`);
    console.log(`‚è≠Ô∏è  Skipped: ${skippedCount} (already exist)`);
    console.log(`üè´ Colleges: ${collegeMap.size}`);
    
  } catch (error) {
    console.error('‚ùå Fatal error during import:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

// Run the import
if (require.main === module) {
  import2022Data()
    .then(() => {
      console.log('\n‚úÖ 2022 data integration complete!');
      process.exit(0);
    })
    .catch((error) => {
      console.error('\n‚ùå Integration failed:', error);
      process.exit(1);
    });
}

export { parse2022Data, import2022Data };
